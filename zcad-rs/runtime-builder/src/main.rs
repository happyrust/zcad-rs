use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::time::{SystemTime, UNIX_EPOCH};

use anyhow::{Context, Result};
use clap::{Args, Parser, Subcommand};
use once_cell::sync::Lazy;
use regex::Regex;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use walkdir::WalkDir;

#[derive(Parser, Debug)]
#[command(name = "runtime-builder", version)]
#[command(about = "复制 ZCAD 运行时资源并生成/校验 manifest", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Command>,
    #[command(flatten)]
    copy: CopyArgs,
}

#[derive(Subcommand, Debug)]
enum Command {
    /// 校验 manifest 中的文件散列与实际运行时目录
    Verify(VerifyArgs),
    /// 解析 Pascal typeexporter 的输入并生成 inc 文件
    #[command(name = "typeexport")]
    TypeExport(TypeExportArgs),
}

#[derive(Args, Debug)]
struct VerifyArgs {
    /// manifest 文件路径
    #[arg(long)]
    manifest: PathBuf,

    /// 可选的运行时根目录（未指定时读取 manifest 里的 target_root）
    #[arg(long)]
    target: Option<PathBuf>,
}

#[derive(Args, Debug)]
struct CopyArgs {
    /// runtimefiles 根目录，默认假定从 rust/ 目录运行
    #[arg(long, default_value = "../environment/runtimefiles")]
    source: PathBuf,

    /// 输出目录（会合并所有运行时文件）
    #[arg(long, default_value = "runtime/dist")]
    target: PathBuf,

    /// 产品目录（zcad 或 zcadelectrotech）
    #[arg(long, default_value = "zcad")]
    product: String,

    /// 平台专用目录，例如 x86_64-win64
    #[arg(long)]
    platform: Option<String>,

    /// 是否在复制前清理输出目录
    #[arg(long)]
    clean: bool,

    /// Manifest 输出路径，默认写入 target/runtime_manifest.json
    #[arg(long)]
    manifest: Option<PathBuf>,
}

#[derive(Args, Debug)]
struct TypeExportArgs {
    /// `cad_source` 根目录
    #[arg(long, default_value = "../cad_source")]
    path_prefix: PathBuf,

    /// typeexporter .files 列表，可多次指定
    #[arg(long = "process-file", value_name = "FILE")]
    process_files: Vec<PathBuf>,

    /// 自定义输出目录（默认为 <path_prefix>/autogenerated）
    #[arg(long)]
    autogen_dir: Option<PathBuf>,

    /// 追加 `{$define SYMBOL}`，等价于 typeexporter 的 define 参数
    #[arg(long = "define", value_name = "SYMBOL")]
    defines: Vec<String>,
}

#[derive(Serialize, Deserialize)]
struct Manifest {
    product: String,
    platform: Option<String>,
    source_root: String,
    target_root: String,
    generated_at_unix: u64,
    files: Vec<ManifestFile>,
}

#[derive(Serialize, Deserialize)]
struct ManifestFile {
    path: String,
    size: u64,
    sha256: String,
}

fn main() {
    if let Err(err) = run() {
        eprintln!("runtime-builder 失败: {err:?}");
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Some(Command::Verify(args)) => {
            verify_manifest(&args)?;
            Ok(())
        }
        Some(Command::TypeExport(args)) => run_type_export(&args),
        None => run_copy(&cli.copy),
    }
}

fn run_copy(args: &CopyArgs) -> Result<()> {
    let source_root = canonicalize_existing(&args.source)
        .with_context(|| format!("无法定位 runtime 源目录 {:?}", args.source))?;
    let target_root = normalize_target(&args.target)?;

    if args.clean && target_root.exists() {
        println!("清理旧的输出目录 {}", target_root.display());
        fs::remove_dir_all(&target_root)
            .with_context(|| format!("无法删除 {}", target_root.display()))?;
    }
    fs::create_dir_all(&target_root)
        .with_context(|| format!("无法创建输出目录 {}", target_root.display()))?;

    let mut segments = Vec::new();
    segments.push(source_root.join("AllCPU-AllOS").join("common"));
    segments.push(source_root.join("AllCPU-AllOS").join(args.product.as_str()));
    if let Some(platform) = &args.platform {
        segments.push(source_root.join(platform).join("common"));
        segments.push(source_root.join(platform).join(args.product.as_str()));
    }

    let mut copied = 0usize;
    for segment in segments {
        copied += copy_segment(&segment, &target_root)?;
    }
    println!("复制完成，共 {} 个文件", copied);

    let manifest_path = args
        .manifest
        .clone()
        .unwrap_or_else(|| target_root.join("runtime_manifest.json"));
    let manifest = build_manifest(
        &target_root,
        ManifestMeta {
            product: &args.product,
            platform: args.platform.as_deref(),
            source: &source_root,
        },
    )?;
    let json = serde_json::to_vec_pretty(&manifest)?;
    if let Some(parent) = manifest_path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("无法创建 manifest 目录 {}", parent.display()))?;
    }
    fs::write(&manifest_path, json)
        .with_context(|| format!("写入 manifest 失败 {}", manifest_path.display()))?;
    println!("已生成 manifest {}", manifest_path.display());

    Ok(())
}

fn run_type_export(args: &TypeExportArgs) -> Result<()> {
    let path_prefix = canonicalize_existing(&args.path_prefix)
        .with_context(|| format!("无法定位 cad_source 根目录 {:?}", args.path_prefix))?;
    let autogen_dir = if let Some(dir) = &args.autogen_dir {
        if dir.is_absolute() {
            dir.clone()
        } else {
            path_prefix.join(dir)
        }
    } else {
        path_prefix.join("autogenerated")
    };
    fs::create_dir_all(&autogen_dir)
        .with_context(|| format!("无法创建目录 {}", autogen_dir.display()))?;
    let allgenerated_path = autogen_dir.join("allgeneratedfiles.inc");
    let buildmode_path = autogen_dir.join("buildmode.inc");

    let mut process_files = if args.process_files.is_empty() {
        vec![PathBuf::from("../environment/typeexporter/zcad.files")]
    } else {
        args.process_files.clone()
    };

    let mut entries = Vec::new();
    for pf in process_files.drain(..) {
        let full = canonicalize_existing(&pf)
            .with_context(|| format!("无法定位 process file {:?}", pf))?;
        let mut list = load_process_file(&full)?;
        entries.append(&mut list);
    }
    if entries.is_empty() {
        println!("未从 process-file 中解析到任何单元，allgeneratedfiles.inc 将为空");
    }

    let mut registrations = Vec::new();
    for rel in &entries {
        let file_path = path_prefix.join(rel);
        let content = fs::read_to_string(&file_path).with_context(|| {
            format!(
                "无法读取 Pascal 文件 {}（来自 process-file）",
                file_path.display()
            )
        })?;
        extract_registrations(&content, &mut registrations);
    }
    println!(
        "识别到 {} 个注册标记，将写入 {}",
        registrations.len(),
        allgenerated_path.display()
    );
    write_allgenerated(&allgenerated_path, &registrations)?;
    write_buildmode(&buildmode_path, &args.defines)?;
    println!(
        "已生成 {}, {}",
        allgenerated_path.display(),
        buildmode_path.display()
    );
    Ok(())
}

fn canonicalize_existing(path: &Path) -> Result<PathBuf> {
    if path.exists() {
        path.canonicalize()
            .with_context(|| format!("解析路径 {:?} 失败", path))
    } else {
        anyhow::bail!("路径 {:?} 不存在", path)
    }
}

fn normalize_target(path: &Path) -> Result<PathBuf> {
    if path.exists() {
        path.canonicalize()
            .with_context(|| format!("解析输出路径 {:?} 失败", path))
    } else if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("无法创建输出父目录 {}", parent.to_string_lossy()))?;
        Ok(path.to_path_buf())
    } else {
        Ok(path.to_path_buf())
    }
}

fn copy_segment(segment: &Path, target: &Path) -> Result<usize> {
    if !segment.exists() {
        println!("跳过 {}（不存在）", segment.display());
        return Ok(0);
    }
    println!("复制 {}", segment.display());
    let mut counter = 0usize;
    for entry in WalkDir::new(segment) {
        let entry = entry?;
        if entry.path() == segment {
            continue;
        }
        let rel = entry
            .path()
            .strip_prefix(segment)
            .context("strip_prefix 失败")?;
        if entry.file_type().is_dir() {
            fs::create_dir_all(target.join(rel))?;
            continue;
        }
        let dest = target.join(rel);
        if let Some(parent) = dest.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::copy(entry.path(), &dest).with_context(|| {
            format!(
                "复制文件失败 {} -> {}",
                entry.path().display(),
                dest.display()
            )
        })?;
        counter += 1;
    }
    Ok(counter)
}

struct ManifestMeta<'a> {
    product: &'a str,
    platform: Option<&'a str>,
    source: &'a Path,
}

fn build_manifest(target: &Path, meta: ManifestMeta<'_>) -> Result<Manifest> {
    if !target.exists() {
        anyhow::bail!("输出目录 {} 不存在", target.display());
    }
    let mut files = Vec::new();
    for entry in WalkDir::new(target) {
        let entry = entry?;
        if entry.file_type().is_dir() {
            continue;
        }
        let rel = entry
            .path()
            .strip_prefix(target)
            .context("strip_prefix manifest 失败")?;
        let rel_str = normalize_rel_path(rel);
        let size = entry.metadata()?.len();
        let sha256 = compute_sha256(entry.path())?;
        files.push(ManifestFile {
            path: rel_str,
            size,
            sha256,
        });
    }
    files.sort_by(|a, b| a.path.cmp(&b.path));
    let generated_at_unix = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();

    Ok(Manifest {
        product: meta.product.to_string(),
        platform: meta.platform.map(|s| s.to_string()),
        source_root: meta.source.to_string_lossy().to_string(),
        target_root: target.to_string_lossy().to_string(),
        generated_at_unix,
        files,
    })
}

fn normalize_rel_path(path: &Path) -> String {
    let mut s = path.to_string_lossy().replace('\\', "/");
    if s.starts_with("./") {
        s = s[2..].to_string();
    }
    s
}

fn compute_sha256(path: &Path) -> Result<String> {
    let mut file = File::open(path).with_context(|| format!("无法打开 {}", path.display()))?;
    let mut hasher = Sha256::new();
    let mut buffer = [0u8; 64 * 1024];
    loop {
        let read = file.read(&mut buffer)?;
        if read == 0 {
            break;
        }
        hasher.update(&buffer[..read]);
    }
    Ok(format!("{:x}", hasher.finalize()))
}

fn load_process_file(path: &Path) -> Result<Vec<PathBuf>> {
    let data = fs::read_to_string(path)
        .with_context(|| format!("读取 process-file 失败 {}", path.display()))?;
    let mut result = Vec::new();
    for line in data.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        let first = trimmed.chars().next().unwrap_or('#');
        if first == '#' || first == ';' {
            continue;
        }
        let value_part = if let Some(idx) = trimmed.find('=') {
            trimmed[idx + 1..].trim()
        } else {
            trimmed
        };
        let normalized = value_part.trim();
        if normalized.is_empty() {
            continue;
        }
        result.push(PathBuf::from(normalized.replace('\\', "/")));
    }
    Ok(result)
}

static REGISTER_REGEX: Lazy<Regex> = Lazy::new(|| {
    Regex::new(
        r"(?is)\{[^}]*?(REGISTEROBJECTTYPE|REGISTEROBJECTWITHOUTCONSTRUCTORTYPE|REGISTERRECORDTYPE)\s+([A-Za-z0-9_]+)",
    )
    .expect("invalid regex")
});

fn extract_registrations(content: &str, acc: &mut Vec<String>) {
    for caps in REGISTER_REGEX.captures_iter(content) {
        if let Some(mat) = caps.get(2) {
            let name = mat.as_str().trim();
            if !name.is_empty() {
                acc.push(name.to_string());
            }
        }
    }
}

fn write_allgenerated(path: &Path, registrations: &[String]) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| format!("无法创建 {}", parent.display()))?;
    }
    let mut file = File::create(path).with_context(|| format!("无法创建 {}", path.display()))?;
    for entry in registrations {
        writeln!(file, "areg{},", entry)
            .with_context(|| format!("写入 {} 失败", path.display()))?;
    }
    Ok(())
}

fn write_buildmode(path: &Path, defines: &[String]) -> Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| format!("无法创建 {}", parent.display()))?;
    }
    let mut file = File::create(path).with_context(|| format!("无法创建 {}", path.display()))?;
    if defines.is_empty() {
        writeln!(file, "{{}}").with_context(|| format!("写入 {} 失败", path.display()))?;
        return Ok(());
    }
    for def in defines {
        if def.trim().is_empty() {
            continue;
        }
        writeln!(file, "{{$define {}}}", def.trim())
            .with_context(|| format!("写入 {} 失败", path.display()))?;
    }
    Ok(())
}

fn verify_manifest(args: &VerifyArgs) -> Result<()> {
    let data =
        fs::read_to_string(&args.manifest).with_context(|| "无法读取 manifest 文件".to_string())?;
    let manifest: Manifest = serde_json::from_str(&data)
        .with_context(|| format!("解析 manifest 失败 {}", args.manifest.display()))?;
    let target_root = if let Some(target) = args.target.as_ref() {
        target.clone()
    } else {
        PathBuf::from(&manifest.target_root)
    };
    if !target_root.exists() {
        anyhow::bail!(
            "运行时目录不存在：{}（可通过 --target 指定）",
            target_root.display()
        );
    }

    let mut missing = Vec::new();
    let mut mismatched = Vec::new();
    for file in &manifest.files {
        let path = target_root.join(&file.path);
        let meta = match fs::metadata(&path) {
            Ok(meta) => meta,
            Err(_) => {
                missing.push(file.path.clone());
                continue;
            }
        };
        if meta.len() != file.size {
            mismatched.push((file.path.clone(), "size"));
            continue;
        }
        let sha = compute_sha256(&path)?;
        if sha != file.sha256 {
            mismatched.push((file.path.clone(), "sha256"));
        }
    }

    if missing.is_empty() && mismatched.is_empty() {
        println!(
            "验证通过：{} 文件全部匹配 {}",
            manifest.files.len(),
            target_root.display()
        );
        return Ok(());
    }

    if !missing.is_empty() {
        println!("缺失文件：");
        for path in &missing {
            println!("  - {path}");
        }
    }
    if !mismatched.is_empty() {
        println!("内容不匹配：");
        for (path, kind) in &mismatched {
            println!("  - {path} ({kind} mismatch)");
        }
    }
    anyhow::bail!(
        "验证失败：{} 个缺失，{} 个不匹配",
        missing.len(),
        mismatched.len()
    );
}
