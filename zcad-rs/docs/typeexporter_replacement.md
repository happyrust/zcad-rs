# Rust 版 typeexporter 生成策略

本备忘梳理 Pascal `typeexporter`（`cad_source/utils/typeexporter.lpr`）当前产物与流程，并提出在 Rust 工作流中重写/集成的方案，重点覆盖 `buildmode.inc`、`zcadversion.inc` 与 `allgeneratedfiles.inc` 三个关键文件。资料来源详见 `BUILD_FROM_SOURCES.md` 与 Pascal 源码。

## 1. 现有产物与依赖

| 产物 | 生成方 | 用途/引用 |
| --- | --- | --- |
| `cad_source/autogenerated/allgeneratedfiles.inc` | `typeexporter` 遍历 `environment/typeexporter/*.files` 指定的 Pascal 单元，根据 `{REGISTEROBJECTTYPE ...}` 等标记自动生成 `areg*.pas` 注册单元，并把所有单元名（逗号分隔）写入该 inc 文件（参见 `cad_source/utils/typeexporter.lpr:120-210`）。 | 被 `cad_source/zcad/gui/uzcmainform.pas:52` 和 `cad_source/zcad.pas:71` 用于注入自动注册单元列表。 |
| `cad_source/autogenerated/buildmode.inc` | `typeexporter` 根据命令行传入的 `define=...` 参数写入 `{$define ...}` 指令；若无 `define`，则写入 `{}`（参见 `cad_source/utils/typeexporter.lpr:440-452`）。 | 通过 `{$INCLUDE buildmode.inc}` 影响最终编译条件，例如 `cad_source/zcad/uzcstrconsts.pas:21`。 |
| `cad_source/zcadversion.inc` + `cad_source/zcadversion.txt` | 非 `typeexporter`，由 Makefile `version` 目标调用 `git describe` 写入（见 `Makefile:216-237`）。`zcadversion.inc` 内容形如 `'v3.3.0-rc2-15-gabcdef'`。 | `cad_source/zcad/uzcsysinfo.pas:33` 内联版本号，CLI/GUI 查询也会读取 `cad_source/zcadversion.txt`。 |
| `cad_source/autogenerated/areg*.pas` | `typeexporter` 针对每个 `{REGISTER...}` 标记创建独立单元（`AutoRegisterPath+filename+'.pas'`），内容包含 `SysUnit.ObjectTypeName2PTD` + 注册调用（见 `cad_source/utils/typeexporter.lpr:129-211`）。 | Pascal 主工程在初始化阶段 `uses areg*` 以完成类型注册。 |
| `cad_source/autogenerated/system.pas` | `typeexporter` 将 `{EXPORT+}/{EXPORT-}` 包裹的内容抽取并写入临时文件，最终重命名为 `$(BUILDPREFIX)/data/rtl/system.pas`（参见 `cad_source/utils/typeexporter.lpr:387-420`）。 | Pascal `system` 单元替换，用于定制类型系统。 |

输入配置：`environment/typeexporter/zcad.files` / `zcadelectrotech.files`（示例见 `environment/typeexporter/zcad.files:1-40`）。语法：`#`/`;` 注释，`+` 作为多个列表的分隔符，列表项为 `cad_source/` 下的相对路径。

## 2. 关键文件生成逻辑细节

### 2.1 allgeneratedfiles.inc

- 标记：`{REGISTEROBJECTTYPE TMyObject}`、`{REGISTEROBJECTWITHOUTCONSTRUCTORTYPE ...}`、`{REGISTERRECORDTYPE ...}`。`typeexporter` 在 `processfileabstract` 中扫描 Pascal 源（`cad_source/utils/typeexporter.lpr:220-320`），一旦匹配，使用 `CreateRegistrationFile*` 生成对应 `areg*.pas`，并调用 `writestring(allgeneratedfiles, filename+',')` 把单元名附加到 inc。
- `filename` = `'areg' + <标记中的名称>`，例如 `aregGZVectorP`。
- inc 文件本质是逗号结尾的模块列表，以便直接插入到 `uses` 列表中（参见 `cad_source/zcad/gui/uzcmainform.pas:52`），因此保持 ``,` 结尾极为重要。

### 2.2 buildmode.inc

- 在 `typeexporter` 结束时写入，若 CLI 不带 `define=...` 则写入 `{}` 占位；否则每个 `define` 写入 `{$define <SYMBOL>}`，顺序与参数顺序一致（`cad_source/utils/typeexporter.lpr:440-452`）。
- Makefile 调用示例：`environment/typeexporter/typeexporter ... define=ELECTROTECH`（`Makefile:246-257`）。Rust 工具需支持可重复的 `--define ELECTROTECH` 参数，并允许读取 `.files` 组合。

### 2.3 zcadversion.inc

- `version` 目标流程（`Makefile:216-237`）：  
  1. `git describe --tags --abbrev=0` 写入 `cad_source/zcadversion.notgit`（若在 git 仓库）。  
  2. `ZCVERSION` 变量优先采用 `git describe --tags --abbrev=0`，若失败则回退 `unknown`.  
  3. `cad_source/zcadversion.inc` 写入 `'$(ZCVERSION)'`（包含单引号）。  
  4. 同步写入 `cad_source/zcadversion.txt`（无引号）。  
- Rust 实现可直接调用 `git describe --tags --long --dirty`（如不可用则读取 `cad_source/zcadversion.notgit` 或 fallback），以保持与 Pascal 版兼容。

## 3. Rust 版实现建议

### 3.1 CLI 设计

- 已在 `runtime-builder` 中新增 `typeexport` 子命令，核心参数与 Pascal 版保持一致：
  - `--path-prefix <cad_source/>`（默认 `../cad_source/`，与仓库结构一致）
  - `--process-file <environment/typeexporter/*.files>`：可多次指定；未提供时默认 `zcad.files`
  - `--autogen-dir <cad_source/autogenerated>`（可选）
  - `--define ELECTROTECH`（可重复）
  - `make -C rust typeexport` 对子命令进行了封装（可通过 `TYPEEXPORT_PROCESS_FILES`、`TYPEEXPORT_DEFINES` 环境变量覆盖默认值）
  - 后续迭代会扩展 `--output-system`、`--emit-json` 等参数
- 子命令应支持 `--dry-run`，输出将生成的文件列表，便于 CI 验证。

### 3.2 allgeneratedfiles 与 areg*.pas

1. **文件列表解析**：读取 `.files`，按 `+` 拆分多个列表；对每条记录执行 `trim` 并忽略空行/注释。
2. **Pascal 解析策略**：  
   - 为保持与旧逻辑一致，可沿用状态机：顺序扫描文件，查找大写化字符串中的 `{REGISTER...}` 与 `{EXPORT+/-}`。  
   - Rust 实现可借助正则或自定义 tokenizer，注意需要保留 `line` 原始大小写（`line` 在写入 `areg` 单元时保持原样）。  
   - 生成 `areg` 单元时重用模板（参照 `CreateRegistrationFile*` 等函数内容）。允许使用 `handlebars`/`tera` 或手写 `format!`, 但要留意 `SysUnit`/`TypeInfo` 等 Pascal 语法的大小写。
3. **inc 写入**：在内存中维护 `Vec<String>`，最终写入 `filename,` 形式，保留 `\n` 分隔；用排序开关（默认保持源文件顺序，确保与 Pascal 行为一致，以减少 diff）。
4. **并行化**：可以多线程扫描，但需保持输出顺序（即 `Vec` 只在 finalize 阶段写入）。

### 3.3 buildmode.inc

- 输入：`Vec<String>` defines。输出：  
  - 若 empty → `{}`。  
  - 否则每行 `{$define SYMBOL}`。  
- 应支持通过配置文件或 CLI 指定 symbol，并允许 `--undef`/`--clear` 以便测试。

### 3.4 zcadversion.inc / zcadversion.txt

- 新增 `runtime-builder version`（或 `typeexport --version-output ...`）执行：  
  1. 读取 `git describe --tags --long --dirty`.  
  2. 写入 `cad_source/zcadversion.inc`（含单引号）与 `cad_source/zcadversion.txt`（纯文本）。  
  3. 若 git 命令失败则尝试读取 `cad_source/zcadversion.notgit`; 如仍失败写入 `'unknown'` 并警告。
- 可通过 `--version-string <value>` 手动覆盖，便于 CI 动态注入。

## 4. 迁移路线图

1. **阶段 A**：在 `runtime-builder` 中实现 `.files` 解析 + `{REGISTER...}` 扫描，生成 `allgeneratedfiles.inc` 与 `buildmode.inc`，暂不输出 `areg*.pas`（先验证 inc 列表）。
2. **阶段 B**：补充 `areg` 模块模板，允许指定输出编码（UTF-8）。完成后为每个文件生成 deterministic 内容，并在 CI 中比对快照。
3. **阶段 C**：复刻 `system.pas` 生成流程（`{EXPORT+}`/`{EXPORT-}` 拷贝），使 Lazarus 版可完全依赖 Rust 工具；同时整合 `zcadversion` 生成。
4. **阶段 D**：与 Pascal 构建流程解耦，提供 `runtime-builder typeexport --emit-config` 将产物路径写入 JSON，供 Rust 构建脚本或包装 CLI 使用。

### 当前状态（Phase A）

- `cargo run -p runtime-builder -- typeexport`（或 `make -C rust typeexport`）会：
  1. 解析 `environment/typeexporter/*.files` 列表；
  2. 扫描 `{REGISTEROBJECTTYPE|REGISTEROBJECTWITHOUTCONSTRUCTORTYPE|REGISTERRECORDTYPE}` 标记；
  3. 生成 `cad_source/autogenerated/allgeneratedfiles.inc`（按出现顺序输出 `areg<符号>,` 列表）；
  4. 生成 `cad_source/autogenerated/buildmode.inc`（若未提供 `--define`，写入 `{}`）。
- 该阶段暂未生成 `areg*.pas` 与 `system.pas`，Pascal/FPC 仍需依赖原 `typeexporter`；但 inc 文件已可供 Rust 版或分析工具使用。

## 5. 风险与未决事项

1. **Pascal 解析兼容性**：原工具允许嵌套 `{EXPORT+}` 块、处理 `{-}...{/pointer/}` 特殊注释。Rust 实现需复刻该语义，建议先编写黄金测试：取当前 `cad_source`，运行现有 `typeexporter` 得到基准 inc，然后与 Rust 版本对比。
2. **平台路径差异**：旧工具假设 Windows 路径分隔符；Rust 版本需要统一使用正斜杠并在写入 inc/单元时保持 Pascal 期待的格式（例如 CRLF 与编码）。建议输出 UTF-8 + LF，并在 Pascal 侧确认可接受。
3. **构建依赖**：`typeexporter` 还生成 `system.pas` 与多个自动注册单元，用于 Pascal/FPC 构建。若 Rust 版只生成 inc 而缺少 `areg*.pas`，Pascal 项目将无法编译。迁移时需么 1) 在 CI 中并行保留 Pascal 工具直到 Rust 版完全覆盖，或 2) 在 Rust 工具内部先调用现有 Pascal 可执行（若可交叉编译）。
4. **性能**：扫描数百 Pascal 文件 + 生成多百个 `areg` 单元，建议缓存文件 mtime，避免每次运行都重建（可添加 `--force`）。

---

本方案后续将结合 `runtime-builder` CLI 实现 `typeexport` 子命令，并通过 manifest/快照测试确保与 Pascal 输出一致。
